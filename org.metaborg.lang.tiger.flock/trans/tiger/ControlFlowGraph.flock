module tiger/Cfg
signature

  sorts
    Id = string
    StrConst = string
    IntConst = int
    
    Exp
    LoopBinding
    Dec
    Type
    Occ
    TypeId
    FArg
	Var
	Int
	LValue
	Hole
	
  constructors
    Mod : Exp -> Exp
    ProcDec : Occ * list(FArg) * Exp -> Dec 
    FunDec : Occ * list(FArg) * Type * Exp -> Dec
    VarDec : Id * Type * Exp -> Dec
    VarDecNoType : Occ * Exp -> Dec
    TypeDec : Occ * Type -> Dec
    Type : TypeId -> Type
    Occ : Id -> Occ 
    Tid : Occ -> TypeId
    DecHole : Hole -> Dec
    Hole : Hole
    
    UMinus : Exp -> Exp
    Minus : Exp * Exp -> Exp
    Plus : Exp * Exp -> Exp
    Times : Exp * Exp -> Exp
    Divide : Exp * Exp -> Exp
    Lt : Exp * Exp -> Exp
    Gt : Exp * Exp -> Exp
    Eq : Exp * Exp -> Exp
    Geq : Exp * Exp -> Exp
    Leq : Exp * Exp -> Exp
    Neq : Exp * Exp -> Exp
    And : Exp * Exp -> Exp
    Or : Exp * Exp -> Exp
    
    Call : Occ * list(Exp) -> Exp
    If : Exp * Exp * Exp -> Exp
    IfThen : Exp * Exp -> Exp
    Seq : list(Exp) -> Exp
    For : LoopBinding * Exp -> Exp
    LoopBinding : Var * Exp * Exp -> LoopBinding
    Assign : LValue * Exp -> Exp
    Let : list(Dec) * list(Exp) -> Exp
    
    String : StrConst -> Exp
    Int : IntConst -> Exp
    Var : Id -> Var
    Array : TypeId * Exp * Exp -> Exp
    Subscript : LValue * Exp -> LValue
    Exp : LValue -> Exp
    LValue : Var -> LValue
    
    
control-flow rules

  root Mod(s) = start -> s -> end
  root ProcDec(n, args, body) = start -> body -> end
  root FunDec(n, args, rt, body) = start -> body -> end

  ProcDec(_, _, _) = entry -> exit
  FunDec(_, _, _, _) = entry -> exit
  TypeDec(_, _) = entry -> exit
  
  TypeDec(occ, t) = entry -> exit
  VarDec(n, t, e) = entry -> e -> this -> exit
  VarDecNoType(n, e) = entry -> e -> this -> exit
  
  UMinus(exp) = entry -> exp -> this -> exit
  Minus(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Plus(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Times(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Divide(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Lt(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Gt(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Eq(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Geq(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Leq(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Neq(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  And(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Or(lhs, rhs) = entry -> lhs -> rhs -> this -> exit
  Subscript(lval, idx) = entry -> idx -> lval -> this -> exit

  Call(_, args) = entry -> args -> this -> exit
  If(c, t, e) = entry -> c -> t -> exit,
                         c -> e -> exit
  LValue(inner) = entry -> inner -> exit
  IfThen(c, t) = entry -> c -> t -> exit
  Assign(lval, expr) = entry -> expr -> lval -> this -> exit
  Seq(stmts) = entry -> stmts -> exit
  For(binding, body) = entry -> binding -> body -> binding,
  	binding -> exit
  LoopBinding(var, from, to) = entry -> from -> to -> this -> exit
  Let(decs, exps) = entry -> decs -> exps -> exit
  Array(_, len, init) = entry -> len -> init -> this -> exit
  Hole() = entry -> exit
  
  node Var(_)
  node Int(_)
  node String(_)
  