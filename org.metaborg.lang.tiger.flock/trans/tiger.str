module tiger

imports

  api
  analysis
  testing
  libstratego-lib
  signatures/tiger-sig
  pp

signature

  constructors
  
    Const: String -> Const

rules // Debugging
  
  debug-show-aterm:
    (node, _, _, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"aterm")> path
    ; result   := node

  debug-show-cfg:
    (p, _, _, path, project-path) -> (filename, result)
    with
      p' := <flock-initialize> p
    ; filename := <guarantee-extension(|"cfg")> path
    ; result := <flock-debug-graph> ()

  debug-show-cfg-spt:
    (p, _, _, path, project-path) -> (filename, result)
    with
      p' := <flock-initialize> p
    ; filename := <guarantee-extension(|"cfg")> path
    ; result := <flock-debug-graph-spt> ()


rules /// editor transformation actions

  editor-transform-const-prop: (p, _, _, path, project-path) -> (filename, result)
    with
      p' := <transform-const-prop> p
    ; filename := <guarantee-extension(|"constprop.tig")> path
    ; result   := <pp-tiger-string> p'

  editor-analyze-const-prop: (p, _, _, path, project-path) -> ()
    with
      p' := <analyze-const-prop> p

  editor-transform-inline: (p, _, _, path, project-path) -> (filename, result)
    with
      p' := <transform-inline> p
    ; filename := <guarantee-extension(|"inlined.tig")> path
    ; result   := <pp-tiger-string> p'  

  editor-analyze-and-transform:
    (p, _, _, path, project-path) -> (filename, result)
    with
      p' := <pipeline> p
    ; filename := <guarantee-extension(|"opt.tig")> path
    ; result   := <pp-tiger-string> p'

rules // transformation actions

  analyze-const-prop: p -> with-ids
    with
      with-ids := <flock-initialize> p
    ; <debug> "Analyzing const prop"
    ; <topdown(try(flock-get-values))> with-ids
    ; <flock-debug-graph(|"values")> ()
  
  transform-const-prop: p -> p'
    with
      with-ids := <flock-initialize> p
    ; p' := <topdown(try(propagate-constant))> with-ids

  transform-inline: p -> p'
    with
      with-ids := <flock-initialize> p
    ; p' := <inline-in-module> with-ids

rules // pipeline

  disable-logs = flock-disable-logging

  pipeline: p -> p'
  with
    with-ids := <flock-initialize> p
  ; <disable-logs> ()
  ; <flock-begin-timer> "pipeline"
  ; p' := <
      inline-pass(|3)
  	; forward-pass(|15)
  	; topdown(try(remove-all(?Hole())))
  > with-ids
  ; <flock-end-timer> "pipeline"
  ; <debug> <run-time>
  ; <flock-debug-graph(|"values")> ()
  
  inline-pass(|n) = flock-fixpoint(inline-in-module|n)

  forward-pass(|n) = flock-fixpoint(forward-pass-single|n)
  forward-pass-single = debug; opt-term
	//bottomup(try(flock-time-as(propagate-constant|"propagate-constant") + flock-time-as(fold-constant|"fold-constant")))
	//bottomup(try(flock-time-as(remove-dead-vardec|"remove-dead-vardec")))
	//oncetd(propagate-constant + simplify-let + simplify-seq + fold-constant + remove-dead-branch)
	//bottomup(try(id))

  // Fail if the term nor any of its subterms can be optimized
  opt-term = 
    preserve-annotation(some(opt-term))
  < try(propagate-constant + fold-constant + simplify-let + simplify-seq + remove-dead-branch)
  + (propagate-constant + fold-constant + simplify-let + simplify-seq + remove-dead-branch)
	
strategies
  
  propagate-constant: lv@LValue(v@Var(n)) -> new-node
  where
   n-no-annos := <strip-annos> n
  ; Const(new-value) := <flock-get-values(|n-no-annos)> v
  ; new-node := <flock-replace-node(|lv)> Int(new-value)
    
  compare-names(|other): (name, value) -> value where <equal(|name, other)> ()
  
  fold-constant: e@Plus(Int(v1), Int(v2)) -> new-node
  where 
    sum := <(string-to-int, string-to-int); addi; int-to-string> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " + ", v2, " -> ", sum]
  ; new-node := <flock-replace-node(|e)> Int(sum)
  
  fold-constant: e@Minus(Int(v1), Int(v2)) -> new-node
  where
    sub := <(string-to-int, string-to-int); subti; int-to-string> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " + ", v2, " -> ", sub]
  ; new-node := <flock-replace-node(|e)> Int(sub)

  fold-constant: e@Times(Int(v1), Int(v2)) -> new-node
  where
    mul := <(string-to-int, string-to-int); muli; int-to-string> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " + ", v2, " -> ", mul]
  ; new-node := <flock-replace-node(|e)> Int(mul)

  fold-constant: e@Eq(Int(v1), Int(v2)) -> new-node
  where
    res := <(string-to-int, string-to-int); eq < !Int("1") + !Int("0")> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " > ", v2]
  ; new-node := <flock-replace-node(|e)> res

  fold-constant: e@Gt(Int(v1), Int(v2)) -> new-node
  where
    res := <(string-to-int, string-to-int); gti < !Int("1") + !Int("0")> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " > ", v2]
  ; new-node := <flock-replace-node(|e)> res

strategies

  remove-dead-branch: e@If(Int("0"), then, else) -> <strip-annos; flock-replace-node(|e)> else
  remove-dead-branch: e@If(Int("1"), then, else) -> <strip-annos; flock-replace-node(|e)> then
  remove-dead-branch: e@IfThen(Int("1"), then) -> <strip-annos; flock-replace-node(|e)> then
  simplify-let: e@Let(decls, [i@Int(n)]) -> <strip-annos; flock-replace-node(|e)> i 
  simplify-seq: e@Seq([inner]) -> <strip-annos; flock-replace-node(|e)> inner
  
strategies

  remove-dead-vardec: a@VarDec(n, _, _) -> new-node
  where
    <not(flock-is-live(|n))> a
  ; new-node := <flock-replace-node(|a)> Hole()
  
  get-vbe: n -> n where <flock-get-ae> n
  
strategies

  inline-in-module: Mod(l@Let(decs, expr){a1*}){a2*} -> Mod(Let(decs, new-expr){a1*}){a2*}
  where
  	  {| InlineFn, InlineCount:
  		<try(bind-fns-in-let-binding)> l
  	  ; new-expr := <bottomup(try(InlineFn))> expr
  	  |}
  	
  inline-rec = rec x({| InlineFn: try(bind-fns-in-let-binding); try(InlineFn); all(x) |})
  
  bind-fns-in-let-binding: Let(bindings, expr) -> <id>
  where
    <retain-all(?FunDecs(fns); !fns); concat; retain-all(no-free-vars; bind-fn)> bindings
  
  // We are relying on the preorder-traversal of topdown to match the way
  // names are bound in the program!
  
  no-free-vars: FunDec(n, params, _, body) -> <id>
  where
  {| BoundName: 
    <map(bind-names)> params
  ; <topdown(try(bind-names); not(free-var))> body
  |}
  
  no-free-vars: ProcDec(n, params, body) -> <id>
  where
  {| BoundName: 
    <map(bind-names)> params
  ; <topdown(try(bind-names); not(free-var))> body
  |}
  	
  bind-names: FArg(n, _) -> <id> where rules(BoundName: n{an*} -> <id>)//; <debug> ("bound", n)
  bind-names: VarDec(n, _, _) -> <id> where rules(BoundName: n{an*} -> <id>)//; <debug> ("bound", n)
  bind-names: LoopBinding(Var(n), _, _) -> <id> where rules(BoundName: n{an*} -> <id>)
  //bind-names: FunDec(n, _, _, _) -> <id> where rules(BoundName: n{an*} -> <id>); <debug> ("bound", n)
  //bind-names: ProcDec(n, _, _) -> <id> where rules(BoundName: n{an*} -> <id>); <debug> ("bound", n)
  
  free-var: t@Var(n) -> <not(BoundName)> n
  //free-var: Call(n, _) -> <not(BoundName)> n

///
 
  bind-fn: FunDec(n, params, rt, body) -> <id>
  where
  	rules(InlineFn: c@Call(n{anno1*}, args{anno2*}){anno3*} -> new-node
  		where
  		  <should-inline> n
  		; replacement := <strip-annos> Let(<create-inlining-decs> (params, args), [body])
  		; new-node := <flock-replace-node(|c)> replacement)
  	
  bind-fn: ProcDec(n, params, body) -> <id>
  where
  	rules(InlineFn: c@Call(n{anno1*}, args{anno2*}){anno3*} -> new-node
  		where
  		  <should-inline> n
  		; replacement := <strip-annos> Let(<create-inlining-decs> (params, args), [body])
  		; new-node := <flock-replace-node(|c)> replacement)

  // This limits the amount of inlining to 3 per function definition
  should-inline: n -> n
  where
    count := <(InlineCount + !0); inc> n
  ; <lt> (count, 3)
  ; rules(InlineCount: n -> count)

  create-inlining-decs = zip; map(create-inlining-dec)
  
  create-inlining-dec: (FArg(occ, ty), arg) -> VarDec(occ, ty, arg)

