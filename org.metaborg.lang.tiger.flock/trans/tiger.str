module tiger

imports

  api
  analysis
  testing
  libstratego-lib
  signatures/tiger-sig
  pp

signature

  constructors
  
    Const: String -> Const

rules // Debugging

  debug-show-aterm:
    (node, _, _, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"aterm")> path
    ; result   := node

  debug-show-cfg:
    (p, _, _, path, project-path) -> (filename, result)
    with
      p' := <flock-initialize> p
    ; filename := <guarantee-extension(|"cfg")> path
    ; result := <flock-debug-graph> ()

  debug-show-cfg-spt:
    (p, _, _, path, project-path) -> (filename, result)
    with
      p' := <flock-initialize> p
    ; filename := <guarantee-extension(|"cfg")> path
    ; result := <flock-debug-graph-spt> ()


rules /// editor transformation actions

  editor-transform-const-prop: (p, _, _, path, project-path) -> (filename, result)
    with
      p' := <transform-const-prop> p
    ; filename := <guarantee-extension(|"constprop.tig")> path
    ; result   := <pp-tiger-string> p'

  editor-analyze-const-prop: (p, _, _, path, project-path) -> ()
    with
      p' := <analyze-const-prop> p

  editor-transform-inline: (p, _, _, path, project-path) -> (filename, result)
    with
      p' := <transform-inline> p
    ; filename := <guarantee-extension(|"inlined.tig")> path
    ; result   := <pp-tiger-string> p'  

  editor-analyze-and-transform:
    (p, _, _, path, project-path) -> (filename, result)
    with
      p' := <pipeline> p
    ; filename := <guarantee-extension(|"opt.tig")> path
    ; result   := <pp-tiger-string> p'

rules // transformation actions

  analyze-const-prop: p -> with-ids
    with
      with-ids := <flock-initialize> p
    ; <debug> "Analyzing const prop"
    ; <topdown(try(flock-get-values))> with-ids
    ; <flock-debug-graph(|"values")> ()
  
  transform-const-prop: p -> p'
    with
      with-ids := <flock-initialize> p
    ; p' := <topdown(try(propagate-constant))> with-ids
	; <flock-debug-graph(|"values")> ()

  transform-inline: p -> p'
    with
      with-ids := <flock-initialize> p
    ; p' := <inline-in-module> with-ids
  
  /*
  * This does inlining only, not composed with other transformations
  * It only inlines loplevel functions
  * Used for testing and debugging
  */
  inline-in-module: Mod(l@Let(decs, expr){a1*}){a2*} -> Mod(Let(decs, new-expr){a1*}){a2*}
  where
  	  {| InlineFn, InlineCount:
  		<try(bind-fns-in-let-binding)> l
  	  ; new-expr := <bottomup(try(InlineFn))> expr
  	  |}
  	  
rules // pipeline

  pipeline: p -> p'
  with
    with-ids := <flock-initialize> p
  //; <flock-disable-logging> ()
  ; <flock-begin-timer> "pipeline"
  ; p' := <
  	  opt-repeat(|5)
  	; topdown(try(remove-all(?Hole())))
  > with-ids
  ; <flock-debug-graph>()
  ; <flock-debug-graph(|"values")> ()
  ; <flock-end-timer> "pipeline"
  ; <debug> <run-time>
  ; <flock-debug-runtime> ()
  
  opt-repeat(|n) = flock-fixpoint(opt|n)
 
  // 1) Dit is de originele implementatie van 'opt'
 
  opt: l@Let(decls, [i@Int(n)]) -> <strip-annos; flock-replace-node(|l)> i
  
  opt: l@Let(decls, expr) -> new-l
  where {| InlineFn, InlineCount:
  	new-l := <some(opt)> l
  |}

  opt: FunDec(n, params, rt, body) -> FunDec(n, params, rt, new-body)
  where
    <finally(opt,
  	    ?new-body
  	  ; rules(InlineFn: c@Call(n{anno1*}, args{anno2*}){anno3*} -> new-node
  		where
  		  <should-inline> n
  		; replacement := <strip-annos> Let(<create-inlining-decs> (params, args), [new-body])
  		; new-node := <flock-replace-node(|c)> replacement)
  	)> body

  opt = preserve-annotation(some(opt)) < try(opt-one) + (opt-one)
  // 2) Deze implementatie heeft de performance issues

  //opt = (?FunDec(n, _, _, _) < fail + (preserve-annotation(some(opt)) < try(opt-one) + (opt-one)))

  // 3) Deze implementatie heeft geen performance issues

  // opt = (?FunDec(_, _, _, _) < fail + (preserve-annotation(some(opt)) < try(opt-one) + (opt-one)))

  // Fail if neither the term nor any of its subterms can be optimized
  opt-one = propagate-constant <+ fold-constant <+ simplify-seq <+ remove-dead-branch /*<+ remove-dead-vardec*/ <+ InlineFn

strategies
  
  propagate-constant: lv@LValue(v@Var(n)) -> new-node
  where
    n-no-annos := <strip-annos> n
  ; Const(c) := <flock-get-values(|n-no-annos)> v
  ; new-node := <flock-replace-node(|lv)> Int(c)

  get-const-value: Const(v) -> v where <debug> v
  get-const-value: _ -> <debug; fail> "not const" where <debug> <id>

  compare-names(|other): (name, value) -> value where <equal(|name, other)> ()
  
  fold-constant: e@Plus(Int(v1), Int(v2)) -> new-node
  where
    sum := <(string-to-int, string-to-int); addi; int-to-string> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " + ", v2, " -> ", sum]
  ; new-node := <flock-replace-node(|e)> Int(sum)

  fold-constant: e@Minus(Int(v1), Int(v2)) -> new-node
  where
    sub := <(string-to-int, string-to-int); subti; int-to-string> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " + ", v2, " -> ", sub]
  ; new-node := <flock-replace-node(|e)> Int(sub)

  fold-constant: e@Times(Int(v1), Int(v2)) -> new-node
  where
    mul := <(string-to-int, string-to-int); muli; int-to-string> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " + ", v2, " -> ", mul]
  ; new-node := <flock-replace-node(|e)> Int(mul)

  fold-constant: e@Eq(Int(v1), Int(v2)) -> new-node
  where
    res := <(string-to-int, string-to-int); eq < !Int("1") + !Int("0")> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " > ", v2]
  ; new-node := <flock-replace-node(|e)> res

  fold-constant: e@Gt(Int(v1), Int(v2)) -> new-node
  where
    res := <(string-to-int, string-to-int); gti < !Int("1") + !Int("0")> (v1, v2)
  ; <concat-strings; flock-debug> ["[fold-expressions] ", v1, " > ", v2]
  ; new-node := <flock-replace-node(|e)> res

strategies

  remove-dead-branch: e@If(Int("0"), then, else) -> <strip-annos; flock-replace-node(|e)> else
  remove-dead-branch: e@If(Int("1"), then, else) -> <strip-annos; flock-replace-node(|e)> then
  remove-dead-branch: e@IfThen(Int("1"), then) -> <strip-annos; flock-replace-node(|e)> then
    
  simplify-seq: e@Seq([inner]) -> <strip-annos; flock-replace-node(|e)> inner
  
strategies

  remove-dead-vardec: a@VarDec(n, _, _) -> new-node
  where
    <not(flock-is-live(|n))> a
  ; new-node := <flock-replace-node(|a)> Hole()

  get-vbe: n -> n where <flock-get-ae> n
  
strategies

  bind-fns-in-let-binding: Let(bindings, expr) -> <id>
  where
    <retain-all(?FunDec(_, _, _, _) + ?ProcDec(_, _, _)); retain-all(no-free-vars; bind-fn)> bindings
   
  // We are relying on the preorder-traversal of topdown to match the way
  // names are bound in the program!
   
  no-free-vars: FunDec(n, params, _, body) -> <id>
  where
  {| BoundName: 
    <map(bind-names)> params
  ; <topdown(try(bind-names); not(free-var))> body
  |}
  
  no-free-vars: ProcDec(n, params, body) -> <id>
  where
  {| BoundName: 
    <map(bind-names)> params
  ; <topdown(try(bind-names); not(free-var))> body
  |}
  	
  bind-names: FArg(n, _) -> <id> where rules(BoundName: n{an*} -> <id>)
  bind-names: VarDec(n, _, _) -> <id> where rules(BoundName: n{an*} -> <id>)
  bind-names: LoopBinding(Var(n), _, _) -> <id> where rules(BoundName: n{an*} -> <id>)
  
  free-var: t@Var(n) -> <not(BoundName)> n

///

  bind-fn: FunDec(n, params, rt, body) -> <id>
  where
    //<concat-strings; debug> ["binding funcdec ", n] ;
  	rules(InlineFn: c@Call(n{anno1*}, args{anno2*}){anno3*} -> new-node
  		where
  		  <should-inline> n
  		//; <debug> "inlining"
  		; replacement := <strip-annos> Let(<create-inlining-decs> (params, args), [body])
  		; new-node := <flock-replace-node(|c)> replacement)

  bind-fn: ProcDec(n, params, body) -> <id>
  where
    //<concat-strings; debug> ["binding procdec ", n] ;
  	rules(InlineFn: c@Call(n{anno1*}, args{anno2*}){anno3*} -> new-node
  		where
  		  <should-inline> n
  		//; <debug> "inlining"
  		; replacement := <strip-annos> Let(<create-inlining-decs> (params, args), [body])
  		; new-node := <flock-replace-node(|c)> replacement)

  // This limits the amount of inlining to 3 per function definition
  should-inline: n -> n
  where  
    count := <(InlineCount + !0); inc> n
  ; <lt> (count, 3)
  ; rules(InlineCount: n -> count)

  create-inlining-decs = zip; map(create-inlining-dec)
  
  create-inlining-dec: (FArg(occ, ty), arg) -> VarDec(occ, ty, arg)

